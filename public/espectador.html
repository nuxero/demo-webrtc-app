<!DOCTYPE html>

<head>
  <title>WebRTC Demo</title>
  <link rel="stylesheet" type="text/css" href="style.css" />
</head>

<body>
  <h1>WebRTC Demo</h1>
  <div id="chat" class="chat">
    <p>Chat:</p>
    <input id="chatText" type="text" placeholder="Escribe un mensaje..." />
    <button id="chatBtn">Enviar</button>
  </div>
  <div class="videos">
    <button id="join">Join</button>
  </div>
  <script src="/socket.io/socket.io.js"></script>
  <script>
    const btn = document.getElementById('join');
    const chat = document.getElementById("chat");
    const chatText = document.getElementById("chatText");
    const chatBtn = document.getElementById("chatBtn");
    const rtcPeerConnections = []
    const dataChannels = []
    const iceServers = {
      'iceServers': [
        { 'urls': 'stun:stun.l.google.com:19302' }
      ]
    }
    let myId;

    btn.addEventListener('click', () => {
      btn.style.display = 'none';
      startSignaling();
    });

    chatBtn.addEventListener('click', () => {
      for (dc in dataChannels) {
        dataChannels[dc].send(myId + ': ' + chatText.value);
      }

      handleReceiveMessage({ data: chatText.value });
      chatText.value = "";
      chatText.focus();
    })

    function startSignaling() {
      const socket = io({
        query: {
          role: 'v'
        }
      });

      socket.on('connect', () => {
        console.log('My id is:', socket.id);
        myId = socket.id
      })

      socket.on('event', evt => {
        switch (evt.type) {
          case 'join':
            console.log(evt.from + ' has joined');
            rtcPeerConnections[evt.from] = createRTCPeerConnection(evt.from);
            dataChannels[evt.from] = rtcPeerConnections[evt.from].createDataChannel('chat');
            dataChannels[evt.from].onmessage = handleReceiveMessage;
            rtcPeerConnections[evt.from].createOffer(evt.role === 'b' ? { offerToReceiveVideo: true } : {}).then(sdp => onOfferAnswer('offer', sdp, evt.from));
            break;
          case 'offer':
            console.log(evt.from + ' has sent an offer:', evt.sdp);
            rtcPeerConnections[evt.from] = createRTCPeerConnection(evt.from);
            rtcPeerConnections[evt.from].ondatachannel = e => receiveChannelCallback(e, evt.from);
            rtcPeerConnections[evt.from].setRemoteDescription(new RTCSessionDescription(evt.sdp));
            rtcPeerConnections[evt.from].createAnswer().then(sdp => onOfferAnswer('answer', sdp, evt.from));
            break;
          case 'answer':
            console.log(evt.from + ' has sent an answer:', evt.sdp);
            rtcPeerConnections[evt.from].setRemoteDescription(new RTCSessionDescription(evt.sdp));
            break;
          case 'candidate':
            console.log(evt.from, 'sent a candidate:', evt.candidate);
            rtcPeerConnections[evt.from].addIceCandidate(new RTCIceCandidate({
              sdpMLineIndex: evt.label,
              candidate: evt.candidate
            }));
            break;
          case 'bye':
            console.log(evt.from + ' has left');
            const videoElement = document.getElementById('remote_' + evt.from);
            if (videoElement) {
              videoElement.pause();
              videoElement.removeAttribute('srcObject'); // empty source
              videoElement.load();
              videoElement.remove();
            }
            if (rtcPeerConnections[evt.from]) {
              rtcPeerConnections[evt.from].close();
            }
            break;
        }
      });

      function sendSignaling(data) {
        socket.emit('event', data);
      }

      function createRTCPeerConnection(remoteUser) {
        const rtcPeerConnection = new RTCPeerConnection(iceServers);
        rtcPeerConnection.onicecandidate = e => onIceCandidate(e, remoteUser);
        rtcPeerConnection.ontrack = e => onAddStream(e, remoteUser);

        return rtcPeerConnection;
      }

      function onOfferAnswer(type, sdp, to) {
        rtcPeerConnections[to].setLocalDescription(sdp);
        console.log('sending ' + type + ' to:', to);
        sendSignaling({
          to: to,
          from: myId,
          type: type,
          sdp: sdp,
        });
      }

      function onIceCandidate(event, to) {
        if (event.candidate) {
          console.log('sending ice candidate to:', to);
          sendSignaling({
            type: 'candidate',
            from: myId,
            to: to,
            label: event.candidate.sdpMLineIndex,
            id: event.candidate.sdpMid,
            candidate: event.candidate.candidate
          })
        }
      }

      function onAddStream(event, from) {
        console.log('got video from', from);
        const remoteVideo = document.createElement('video');
        remoteVideo.id = 'remote_' + from;
        remoteVideo.autoplay = true;
        remoteVideo.srcObject = new MediaStream([event.track]);
        document.getElementsByClassName('videos')[0].appendChild(remoteVideo);
      }
    }

    function receiveChannelCallback(event, from) {
      dataChannels[from] = event.channel;
      dataChannels[from].onmessage = handleReceiveMessage;
    }

    function handleReceiveMessage(e) {
      const el = document.createElement('p');
      const txtNode = document.createTextNode(e.data);
      el.appendChild(txtNode);

      chat.appendChild(el);
    }
  </script>
</body>